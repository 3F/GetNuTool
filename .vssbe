{
  "Header": {
    "_": [
      " This file for vsSolutionBuildEvent ",
      " https://github.com/3F/vsSolutionBuildEvent "
    ],
    "Compatibility": "0.12.4"
  },
  "PreBuild": [
    {
      "Enabled": true,
      "Name": "Prepare",
      "Caption": "Prepare data and directories",
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[$(dbin = \"bin/Release/\")]",
          "#[$(dobj = \"obj/\")]",
          "",
          "~ Inputs",
          "",
          "$(fCore = '$(dobj)core')",
          "$(fCoreMin = '$(dobj)gnt.min.core')",
          "$(fPacked = '$(dobj)gnt.bat')",
          "$(fEmbd = 'embd.bat')",
          "$(fCaller = '$(dobj)caller.bat')",
          "$(fPackMin = '$(dobj)gnt.minified.bat')",
          "",
          "#[($(packmaxline) == *Undefined*){ $(packmaxline = '1900') }]",
          "",
          "~ Output structure",
          "",
          "$(odir = \"$(dbin)raw/\")",
          "",
          "#[IO delete.directory(\"$(dbin)\", true)]",
          "#[IO copy.directory(\"\", \"$(dbin)\", true)]",
          "#[IO copy.directory(\"\", \"$(dobj)\", true)]"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "ActCs",
      "SupportMSBuild": false,
      "IgnoreIfBuildFailed": true,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "",
          "initialize without msbuild processing",
          "#[var cslogic = #[IO get(\"csharp.cs\")]]"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "ActCore",
      "IgnoreIfBuildFailed": true,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[$(revDeltaBase = \"2015/12/09\")]",
          "#[$(revDeltaMin  = 1000)] #[$(revDeltaMax  = 9999)]",
          "",
          "#[var pVer = #[File get(\".version\")]]",
          "",
          "~ Calculate revision",
          "",
          "#[var tBase     = $([System.DateTime]::Parse('$(revDeltaBase)').ToBinary())]",
          "#[var tNow      = $([System.DateTime]::UtcNow.Ticks)]",
          "#[var revBuild  = #[$(",
          "    [System.TimeSpan]::FromTicks('$(",
          "        [MSBuild]::Subtract($(tNow), $(tBase))",
          "    )')",
          "    .TotalMinutes.ToString('0')",
          ")]]",
          "",
          "#[var revBuild  = #[$(",
          "    [MSBuild]::Add(",
          "        $(revDeltaMin), ",
          "        $([MSBuild]::Modulo(",
          "            $(revBuild), ",
          "            $([MSBuild]::Subtract(",
          "                $(revDeltaMax), $(revDeltaMin)",
          "             ))",
          "         ))",
          "     )",
          "   )]",
          "]",
          "",
          "#[$(pVerPrintFile = \"$(pVer).$(revBuild)\"))]",
          "",
          "#[\" ",
          "    Checking of the git folder +tool & define sha1, branch name, etc.",
          "\"]",
          "#[var isGit = #[IO cmd(\"git rev-parse 2>&1\", 120)]]",
          "#[( $(isGit) == \"\" )",
          "{",
          "    #[var bSha1 = #[IO sout(\"git\", \"rev-parse --short HEAD\")]]",
          "    ",
          "    #[$(pVerPrintFile = \"$(pVerPrintFile)+$(bSha1)\")]",
          "}",
          "else {",
          "    #[$(bSha1 = '-')]",
          "}]",
          "",
          "#[( $(reltype) == \"PublicRelease\" ) {",
          "    #[$(pVerPrintApp = \"$(pVer).$(revBuild)+$(bSha1)\")]",
          "    $(isPubRel = true)",
          "}",
          "else {",
          "    #[$(pVerPrintApp = $(pVer))]",
          "    $(isPubRel = false)",
          "}]",
          "",
          "#[\" obj \"]",
          "",
          "#[IO copy.file(\"csinit.targets\", \"$(dobj)core\", true)]",
          "#[IO replace.Regex(\"$(dobj)core\", \"<GetNuTool>.*?</GetNuTool>\", \"<GetNuTool>$(pVerPrintApp)</GetNuTool>\")]",
          "",
          "$ -> $$ to prevent double evaluation",
          "#[IO replace",
          "(",
          "    \"$(dobj)core\",",
          "    \"return true;\",",
          "    \"$(cslogic.Replace('$(', '$$('))\"",
          ")]"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "CompressorMinified",
      "Caption": ".compressor at /minified ",
      "SupportSBEScripts": false,
      "IgnoreIfBuildFailed": true,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeCSharp, vsSolutionBuildEvent",
        "Type": "CSharp",
        "References": [
          "System.dll",
          "System.Core.dll"
        ],
        "SmartReferences": true,
        "GenerateInMemory": true,
        "TreatWarningsAsErrors": false,
        "WarningLevel": 4,
        "FilesMode": false,
        "CachingBytecode": false,
        "Command__": [
          "/*",
          "*   Copyright (c) 2015  Denis Kuzmin <x-3F@outlook.com> github/3F",
          "*",
          "*   Licensed under the GetNuTool license",
          "*   https://github.com/3F/GetNuTool",
          "*/",
          "",
          "using System;",
          "using System.Collections.Generic;",
          "using System.IO;",
          "using System.Linq;",
          "using System.Text;",
          "using System.Text.RegularExpressions;",
          "using ICommand = net.r_eg.vsSBE.Actions.ICommand;",
          "using ISolutionEvent = net.r_eg.vsSBE.Events.ISolutionEvent;",
          "",
          "namespace vsSolutionBuildEvent",
          "{",
          "    public class CSharpMode",
          "    {",
          "        public static int Init(ICommand cmd, ISolutionEvent evt)",
          "        {",
          "            const string _CORE = @\"$(fCore)\";",
          "            const string _OUTPUT = @\"$(fCoreMin)\";",
          "",
          "            Func<char, string> quotes = (symbol) => string.Format",
          "            (@\"",
          "                (?<!\\\\)",
          "                (",
          "                {0}(?:",
          "                     (?:",
          "                        [^{0}\\\\\\n]",
          "                      |",
          "                        \\\\\\\\",
          "                      |",
          "                        \\\\{0}?",
          "                     )*",
          "                    ){0}",
          "                )\",",
          "                symbol",
          "            );",
          "",
          "            Func<char[], int, Func<int, bool>, string[]> gencomb = (_dict, _size, _rule0) =>",
          "            {",
          "                var combination = new char[_size];",
          "                var set = new List<string>((int)Math.Pow(_dict.Length, _size));",
          "",
          "                int pos = 0;",
          "                Action generator = null;",
          "                generator = () =>",
          "                {",
          "                    for(int i = 0, lim = _size - 1; i < _dict.Length; ++i)",
          "                    {",
          "                        if(pos == 0 && !_rule0(i))",
          "                        {",
          "                            continue;",
          "                        }",
          "",
          "                        if(pos < lim)",
          "                        {",
          "                            combination[pos] = _dict[i];",
          "                            ++pos;",
          "                            generator();",
          "                            --pos;",
          "                        }",
          "                        else",
          "                        {",
          "                            combination[pos] = _dict[i];",
          "                            set.Add(new string(combination.ToArray()));",
          "                        }",
          "                    }",
          "                };",
          "",
          "                generator();",
          "                return set.ToArray();",
          "            };",
          "",
          "            var variables = new Dictionary<string, string>();",
          "",
          "            var cdict = new[]",
          "            {",
          "                'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',",
          "                'U', 'V', 'W', 'X', 'Y', 'Z',",
          "                'D', 'E', 'F', 'G', 'H', 'I', 'J',",
          "                'A', 'B', 'C',",
          "",
          "                'd', 'e', 'f', 'g', 'h', 'i', 'j',",
          "                'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',",
          "                'u', 'v', 'w', 'x', 'y', 'z',",
          "                'a', 'b', 'c',",
          "",
          "                '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',",
          "                '_'",
          "            };",
          "",
          "            Func<int, bool> rule = (i) => { return char.IsLetter(cdict[i]) || cdict[i] == '_'; };",
          "            var vdict1 = gencomb(cdict, 1, rule);",
          "            var vdict2 = gencomb(cdict, 2, rule);",
          "",
          "            var vdict = new string[vdict1.Length + vdict2.Length];",
          "            vdict1.CopyTo(vdict, 0);",
          "            vdict2.CopyTo(vdict, vdict1.Length);",
          "",
          "            // to skip processing for:",
          "            var exvar = new string[] { \"true\", \"false\" };",
          "",
          "            // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/",
          "            var rsvwords = new[] { \"do\", \"in\", \"is\", \"as\", \"if\", \"by\", \"on\" };",
          "",
          "            using(var reader = new StreamReader(_CORE, Encoding.UTF8, true))",
          "            {",
          "                string content = reader.ReadToEnd();",
          "",
          "                // protect strings",
          "",
          "                var strings = new Dictionary<uint, string>();",
          "                uint ident = 0;",
          "                content = Regex.Replace",
          "                (",
          "                    content,",
          "                    string.Format(@\"({0}|{1})\", quotes('\"'), quotes('\\'')),",
          "                    (m) =>",
          "                    {",
          "                        ++ident;",
          "                        strings[ident] = m.Groups[1].Value;",
          "                        return string.Format(\"!s{0}!\", ident);",
          "                    },",
          "                    RegexOptions.IgnorePatternWhitespace",
          "                );",
          "",
          "                // code",
          "",
          "                content = Regex.Replace(content, @\"<!\\[CDATA\\[.+?\\]\\]>\", (m) =>",
          "                {",
          "                    string data = m.Value;",
          "",
          "                    // comments",
          "",
          "                    data = Regex.Replace(data, @\"\\s*\\/\\*.+?\\*\\/\\s*\", \"\", RegexOptions.Singleline);",
          "                    data = Regex.Replace(data, @\"\\s*\\/\\/.+?$\", \"\", RegexOptions.Multiline);",
          "",
          "                    // shorten variables",
          "                    // TODO: sort by popularity of use with 1 byte priority",
          "",
          "                    variables.Clear();",
          "                    uint uniqVars = 0;",
          "",
          "                    Func<string, string> allocvar = (vname) =>",
          "                    {",
          "                        if(uniqVars + 1 > vdict.Length) throw new OverflowException(\"vdict does not contain data for new vars\");",
          "                        do",
          "                        {",
          "                            variables[vname] = vdict[uniqVars++];",
          "                        }",
          "                        while(rsvwords.Contains(variables[vname]));",
          "",
          "                        return variables[vname];",
          "                    };",
          "",
          "                    Func<Match, string, string, string, string> shname = (_m, l, vname, r) =>",
          "                    {",
          "                        if(exvar.Contains(vname) /*TODO: L-66 || variables.ContainsValue(vname)*/) return _m.Value;",
          "                        if(variables.ContainsKey(vname)) return l + variables[vname] + r;",
          "",
          "                        return l + allocvar(vname) + r;",
          "                    };",
          "",
          "                    Func<string, string> shnameLArgs = (vname) =>",
          "                    {",
          "                        if(variables.ContainsKey(vname)) return variables[vname];",
          "                        return allocvar(vname);",
          "                    };",
          "",
          "                    //data = Regex.Replace(data, @\"([\\s;},])String([\\s.(]+)\", \"$1string$2\");",
          "                    data = Regex.Replace(data, @\"([<\\^,\\s(.{!};=])string([\\^,\\s.\\[>])\", \"$1String$2\"); // ...String is better for Packer ",
          "                    data = Regex.Replace(data, @\"[sS]tring\\s*\\.\\s*Empty\", \"\\\"\\\"\");",
          "                    data = Regex.Replace(data, @\"\\s*const\\s+[sS]tring\\s+\", \"var \");",
          "                    data = Regex.Replace(data, @\"([;(){}]\\s*)\\w+(?:\\s*\\[\\])?\\s+(\\w+)\\s*(in|=)\\s*\", \" $1 var $2 $3 \");",
          "                    data = Regex.Replace(data, @\"\\s*([{}()=+\\-\\[\\]*?!@,;.])\\s*\", \"$1\");",
          "",
          "                    data = Regex.Replace",
          "                    (",
          "                        data,",
          "                        @\"(?:",
          "                            (?'type'",
          "                                \\w+\\s*<[\\w_<,\\s>\\[\\]]+>",
          "                                |",
          "                                \\w+[\\(\\s]*",
          "                            )",
          "                            \\s+",
          "                            (?'name'\\w+)",
          "                            \\s*",
          "                            (?'lim'",
          "                                (?:[+\\-*\\/]?=|\\s+in\\s+|[,)]|\\s*;)",
          "                            )",
          "                        |",
          "                            (?'fl'[(\\s])*(?'lmbd'[^.()=]+?)(?'fr'[)\\s]*)=>",
          "                        )",
          "                        \",",
          "                        (_m) =>",
          "                        {",
          "                            var vname = _m.Groups[\"name\"];",
          "                            if(vname.Success)",
          "                            {",
          "                                return shname(_m, _m.Groups[\"type\"].Value + \" \", vname.Value, _m.Groups[\"lim\"].Value);",
          "                            }",
          "",
          "                            var lmbd = _m.Groups[\"lmbd\"];",
          "                            if(lmbd.Success)",
          "                            {",
          "                                var sb = new StringBuilder();",
          "                                foreach(string arg in lmbd.Value.Split(new[] { ',' }))",
          "                                {",
          "                                    sb.Append(shnameLArgs(arg));",
          "                                    sb.Append(',');",
          "                                }",
          "",
          "                                sb.Remove(sb.Length - 1, 1);",
          "                                string fargs = sb.ToString();",
          "",
          "                                string fl = _m.Groups[\"fl\"].Value;",
          "                                string fr = _m.Groups[\"fr\"].Value;",
          "",
          "                                if(!lmbd.Value.Contains(',') && fr == \")\") fl = fr = \"\";",
          "",
          "                                return string.Format(\"{0}{1}{2}=>\", fl, fargs, fr);",
          "                            }",
          "",
          "                            return _m.Value;",
          "                        },",
          "                        RegexOptions.IgnorePatternWhitespace | RegexOptions.IgnoreCase",
          "                    );",
          "",
          "                    // using of variables",
          "                    data = Regex.Replace",
          "                    (",
          "                        data,",
          "                        @\"(?'def'^|[\\s}]else\\s|\\s+in\\s+|(?<==)>|[!={};:\\[(),?+\\-|&])",
          "                            \\s*",
          "                            (?'name'\\w+)",
          "                            (?'exc'[<>]*)?",
          "                        \",",
          "                        (Match _m) =>",
          "                        {",
          "                            var def = _m.Groups[\"def\"].Value;",
          "                            var vname = _m.Groups[\"name\"].Value;",
          "                            var exc = _m.Groups[\"exc\"].Value;",
          "",
          "                            if(exc.IndexOfAny(new[] { '<', '>' }) != -1) return _m.Value;",
          "",
          "                            if(!Regex.IsMatch(vname, \"^[a-zA-Z_]\")) return _m.Value;",
          "",
          "                            if(!variables.ContainsKey(vname))",
          "                            {",
          "                                return def + vname + exc;",
          "                            }",
          "                            return def + variables[vname] + exc;",
          "                        },",
          "                        RegexOptions.IgnorePatternWhitespace | RegexOptions.IgnoreCase | RegexOptions.Multiline",
          "                    );",
          "",
          "                    // predefined",
          "",
          "                    data = data.Replace(\"StringComparison.OrdinalIgnoreCase\", \"(StringComparison)5\");",
          "                    data = data.Replace(\"StringComparison.Ordinal\", \"(StringComparison)4\");",
          "                    data = data.Replace(\"SearchOption.AllDirectories\", \"(SearchOption)1\");",
          "                    data = data.Replace(\"FileMode.Open\", \"(FileMode)3\");",
          "                    data = data.Replace(\"FileAccess.Read\", \"(FileAccess)1\");",
          "                    data = data.Replace(\"UriKind.Relative\", \"(UriKind)2\");",
          "                    data = data.Replace(\"FileMode.Create\", \"(FileMode)2\");",
          "                    data = data.Replace(\"CompressionOption.Maximum\", \"(CompressionOption)1\");",
          "                    data = data.Replace(\"StringSplitOptions.RemoveEmptyEntries\", \"(StringSplitOptions)1\");",
          "",
          "                    // 0",
          "                    data = data.Replace(\"TargetMode.Internal\", \"0\");",
          "                    data = data.Replace(\"SearchOption.TopDirectoryOnly\", \"0\");",
          "",
          "                    return data;",
          "                },",
          "                RegexOptions.Singleline);",
          "",
          "                // common rules",
          "",
          "                content = content.Replace(\"\\r\", \"\").Replace(\"\\n\", \"\");",
          "                content = Regex.Replace(content, @\"\\s{2,}\", \" \");",
          "                content = Regex.Replace(content, @\"\\s*([=,()\\[\\];:.&|{}\\/<>]+)\\s*\", \"$1\");",
          "",
          "                /* XML */",
          "",
          "                Action<Dictionary<string, string>, int> writeMap = (vars, part) =>",
          "                {",
          "                    using(var wmap = new StreamWriter(string.Format(\"{0}.{1}.map\", _OUTPUT, part), false, new UTF8Encoding(false)))",
          "                    {",
          "                        string map = string.Empty;",
          "                        foreach(var v in vars) map += string.Format(\"{0}={1}{2}\", v.Value, v.Key, Environment.NewLine);",
          "                        wmap.Write(map);",
          "                    }",
          "                };",
          "                writeMap(variables, 0);",
          "",
          "                // XML rules",
          "",
          "                content = Regex.Replace(content, @\"<!--.+?-->\", \"\");",
          "                content = Regex.Replace(content, @\">\\s+<\", \"><\");",
          "                content = Regex.Replace(content, @\"\\s+\\/>\", \"/>\");",
          "",
          "                // recover strings",
          "",
          "                content = Regex.Replace(content, @\"!s(\\d+)!\", (m) => {",
          "                    return strings[uint.Parse(m.Groups[1].Value)];",
          "                });",
          "",
          "                // xml Tasknames",
          "",
          "                variables.Clear();",
          "                uint uniqt = 0;",
          "                content = Regex.Replace(content, @\"TaskName\\s*=\\s*\"\"(?'name'\\S+)\"\"\", (_m) =>",
          "                {",
          "                    var tname = _m.Groups[\"name\"].Value;",
          "",
          "                    variables[tname] = vdict[uniqt++];",
          "",
          "                    return \"TaskName=\\\"\" + variables[tname] + \"\\\"\";",
          "                });",
          "",
          "                content = Regex.Replace(content, @\"(?'l'<\\/?)(?'name'[a-z0-9A-Z\\-_]+)\", (_m) =>",
          "                {",
          "                    var tname = _m.Groups[\"name\"].Value;",
          "",
          "                    if(variables.ContainsKey(tname))",
          "                    {",
          "                        return _m.Groups[\"l\"].Value + variables[tname];",
          "                    }",
          "",
          "                    return _m.Value;",
          "                });",
          "",
          "                // XML rules - Post filter",
          "",
          "                content = Regex.Replace(content, @\"\\s+ParameterType\\s*=\\s*\"\"System.String\"\"\\s*\", \" \");",
          "                content = Regex.Replace(content, @\"\\s+Required\\s*=\\s*\"\"\\S+\"\"\\s*\", \" \");",
          "                content = Regex.Replace(content, @\"\\s+(\\/)?>\", \"$1>\");",
          "                content = Regex.Replace(content, @\"'\\s*==\\s*'\", \"'=='\");",
          "",
          "                using(var writer = new StreamWriter(_OUTPUT, false, new UTF8Encoding(false)))",
          "                writer.Write(content.Replace(\"$$\", \"$\"));",
          "",
          "                writeMap(variables, 1);",
          "                Console.WriteLine(\"{0} -> {1}\", _CORE, _OUTPUT);",
          "            }",
          "",
          "            return 0;",
          "        }",
          "    }",
          "}"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "Packer",
      "Caption": ".packer at /embedded",
      "SupportSBEScripts": false,
      "IgnoreIfBuildFailed": true,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeCSharp, vsSolutionBuildEvent",
        "Type": "CSharp",
        "References": [
          "System.dll",
          "System.Core.dll"
        ],
        "SmartReferences": true,
        "GenerateInMemory": true,
        "TreatWarningsAsErrors": false,
        "WarningLevel": 4,
        "FilesMode": false,
        "CachingBytecode": false,
        "Command__": [
          "/*",
          "*   Copyright (c) 2015  Denis Kuzmin <x-3F@outlook.com> github/3F",
          "*",
          "*   Licensed under the GetNuTool license",
          "*   https://github.com/3F/GetNuTool",
          "*/",
          "",
          "using System;",
          "using System.Collections.Generic;",
          "using System.IO;",
          "using System.Linq;",
          "using System.Text;",
          "using System.Text.RegularExpressions;",
          "using ICommand = net.r_eg.vsSBE.Actions.ICommand;",
          "using ISolutionEvent = net.r_eg.vsSBE.Events.ISolutionEvent;",
          "",
          "namespace vsSolutionBuildEvent",
          "{",
          "    public class CSharpMode",
          "    {",
          "        public static int Init(ICommand cmd, ISolutionEvent evt)",
          "        {",
          "            const string _CORE = @\"$(fCoreMin)\";",
          "            const string _OUTPUT = @\"$(fPacked)\";",
          "            const string _EMBDTPL = @\"$(fEmbd)\";",
          "",
          "            Func<char, string> quotes = (symbol) =>",
          "            {",
          "                return string.Format",
          "                (@\"",
          "                    (?<!\\\\)",
          "                    (",
          "                     {0}(?:",
          "                         (?:",
          "                              [^{0}\\\\]",
          "                            |",
          "                              \\\\\\\\",
          "                            |",
          "                              \\\\{0}?",
          "                         )*",
          "                        ){0}",
          "                    )\",",
          "                    symbol",
          "                );",
          "            };",
          "",
          "            Func<string, Dictionary<int, int>> scalc = (content) =>",
          "            {",
          "                var data = new Dictionary<int, int>(); // \"(start) -> \"(length)",
          "",
          "                var matches = Regex.Matches(content, quotes('\"'), RegexOptions.IgnorePatternWhitespace);",
          "                foreach(Match m in matches) {",
          "                    data[m.Index] = m.Length;",
          "                }",
          "                return data;",
          "            };",
          "",
          "            Func<int, Dictionary<int, int>, bool> isInsideString = (idx, strings) =>",
          "            {",
          "                foreach(var s in strings)",
          "                {",
          "                    if(idx > s.Key && idx < (s.Key + s.Value)) {",
          "                        return true;",
          "                    }",
          "                }",
          "                return false;",
          "            };",
          "",
          "            Func<char[], int, Func<int, bool>, string[]> gencomb = (_dict, _size, _rule0) =>",
          "            {",
          "                var combination = new char[_size];",
          "                var set         = new List<string>((int)Math.Pow(_dict.Length, _size));",
          "",
          "                int pos = 0;",
          "                Action generator = null;",
          "                generator = () =>",
          "                {",
          "                    for(int i = 0, lim = _size - 1; i < _dict.Length; ++i)",
          "                    {",
          "                        if(pos == 0 && !_rule0(i)) {",
          "                            continue;",
          "                        }",
          "",
          "                        if(pos < lim) {",
          "                            combination[pos] = _dict[i];",
          "                            ++pos;",
          "                            generator();",
          "                            --pos;",
          "                        }",
          "                        else {",
          "                            combination[pos] = _dict[i];",
          "                            set.Add(new String(combination.ToArray()));",
          "                        }",
          "                    }",
          "                };",
          "",
          "                generator();",
          "                return set.ToArray();",
          "            };",
          "",
          "            var variables = new Dictionary<string, string>();",
          "",
          "            var cdict = new[]",
          "            {",
          "                '-', '[', ']', ';', '.', ',', ':', '+', '{', '}', '_',",
          "                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',",
          "                'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',",
          "                'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3',",
          "                '4', '5', '6', '7', '8', '9',",
          "                '$', '#', '@', '`', '?',",
          "                '!',",
          "            };",
          "",
          "            var vdict = gencomb(cdict, 1, (i) => { return !char.IsDigit(cdict[i]); });",
          "",
          "            const string chValidInBat = @\"[a-z0-9A-Z%!:;\\-\\[\\].,+{}_$#@`?]\";",
          "",
          "            // to skip processing for:",
          "            var exword      = new[] { \"Target\", \"null\" };",
          "            int skipFirst   = 110;",
          "            ",
          "            var pwords = new string[]",
          "            {",
          "                \"Credential\",",
          "                \"Environment\",",
          "                \"package\",",
          "                \"String\",",
          "                //\"MSBuild\",",
          "                @\"\\.IsNullOr\",",
          "                \"SecurityProtocol\",",
          "                @\"Console\\s*\\.\\s*WriteLine\\(\\s*\",",
          "                //@\"String\\.IsNullOr\",",
          "                @\"Console\\s*\\.\\s*Error\\s*\\.\\s*WriteLine\\(\\s*\",",
          "                //@\"String\\.IsNullOrEmpty\\(\\s*\",",
          "                @\"Microsoft\\.Build\\.Tasks\\.\",",
          "                @\"Console\\.Write\\(\",",
          "                @\"\\.Trim\\(\\)\",",
          "                //@\"ServicePointManager\\.SecurityProtocol\",",
          "                @\"\\.Name\\.LocalName\",",
          "                @\"http:\\/\\/schemas\\.microsoft\\.com/\",",
          "                @\"\\);var \",",
          "                @\"\\);if\\(\",",
          "                @\"\\)\\{var \",",
          "                @\"XDocument\\.Load\\(\",",
          "                @\"\\)continue;var \",",
          "                @\"Start\\(\",",
          "                \"Exception\",",
          "                //@\"packages\\.config\",",
          "                @\";}catch\\(\",",
          "                @\"\\.Create\",",
          "                @\"\\(var \",",
          "                @\";var \",",
          "                @\"=null\",",
          "                @\":null\",",
          "                \";Action\",",
          "                \"true;\",",
          "            };",
          "",
          "            string rlexemes = @\"(?:",
          "                (?'wrd'",
          "                    \" + string.Join(\"|\", pwords) + @\"",
          "                )",
          "                |",
          "                (?'ld'(?:%%?0[aA]|\\.))?",
          "                (?'cls'[a-z0-9A-Z_\\-]+)",
          "              )\";",
          "",
          "            using(var reader = new StreamReader(_CORE, System.Text.Encoding.UTF8, true))",
          "            {",
          "                string content = reader.ReadToEnd()",
          "                                .Replace(\"\\r\\n\", \"\\n\").Replace(\"\\n\", \"\\r\\n\"); // F-148",
          "",
          "                content = content.Replace(\"%\", \"%%\");",
          "                ",
          "                // Protecting data outside strings only:",
          "                content = Regex.Replace(content, @\"[<|>&]\", (m) => isInsideString(m.Index, scalc(content)) ? m.Value : \"^\" + m.Value);",
          "",
          "                // lexemes via vars",
          "",
          "                var lstat = new Dictionary<string, int>();",
          "                foreach(Match m in Regex.Matches(content, rlexemes, RegexOptions.IgnorePatternWhitespace))",
          "                {",
          "                    var wrd = m.Groups[\"wrd\"];",
          "                    var cls = m.Groups[\"cls\"];",
          "",
          "                    var vname = wrd.Success ? wrd.Value : cls.Value;",
          "",
          "                    if(vname.Length < 4) { // minimal is 3: %a%",
          "                        continue;",
          "                    }",
          "",
          "                    if(exword.Contains(vname)) {",
          "                        continue;",
          "                    }",
          "                    ",
          "                    if(!wrd.Success)",
          "                    {",
          "                        string pword = pwords.FirstOrDefault(w => vname.Contains(w));",
          "                        if(pword != null) vname = pword;",
          "                    }",
          "",
          "                    if(!lstat.ContainsKey(vname)) {",
          "                        lstat[vname] = -1 * (vname.Length + 7); //for init: set a= + length + &",
          "                    }",
          "                    lstat[vname] += (vname.Length - 3); //for use: % + a + %",
          "                }",
          "                ",
          "                uint uniqVars = 0;",
          "                variables.Clear();",
          "                var prio = lstat.Where(x => x.Value > 0).OrderByDescending(x => x.Value).Take(vdict.Length);",
          "                var defv = \"\";",
          "                var defSchemasVar = new KeyValuePair<string, string>(null, null);",
          "",
          "                content = Regex.Replace(content, rlexemes, (m) => ",
          "                {",
          "                    if(m.Index < skipFirst) return m.Value;",
          "",
          "                    var wrd = m.Groups[\"wrd\"];",
          "                    var cls = m.Groups[\"cls\"];",
          "                    var ld  = m.Groups[\"ld\"].Value;",
          "",
          "                    var vname = wrd.Success ? wrd.Value : cls.Value;",
          "",
          "                    if(prio.All(x => x.Key != vname)) {",
          "                        return m.Value;",
          "                    }",
          "",
          "                    if(variables.ContainsKey(vname)) {",
          "                        return ld + variables[vname];",
          "                    }",
          "",
          "                    if(uniqVars + 1 > vdict.Length) {",
          "                        throw new OverflowException(\"vdict does not contain data for new vars\");",
          "                    }",
          "",
          "                    var nv = vdict[uniqVars++];",
          "",
          "                    variables[vname] = string.Format(\"%{0}%\", nv);",
          "",
          "                    if(vname.Contains(\"schemas.microsoft\"))",
          "                        defSchemasVar = new KeyValuePair<string, string>(nv, vname);",
          "",
          "                    defv += string.Format(\"set {0}={1}&\", nv, vname);",
          "                    return ld + variables[vname];",
          "                },",
          "                RegexOptions.IgnorePatternWhitespace);",
          "",
          "                // reuse word parts",
          "                content = Regex.Replace(content, rlexemes, (m) => ",
          "                {",
          "                    if(m.Index < skipFirst) return m.Value;",
          "",
          "                    string ret = m.Value;",
          "                    if(m.Groups[\"wrd\"].Success) return ret;",
          "",
          "                    foreach(var vkey in variables.Keys)",
          "                    {",
          "                        int pros = vkey.Length - /* % + a + % */3;",
          "                        if(pros >= 0 && ret != vkey && ret.Contains(vkey))",
          "                            return ret.Replace(vkey, variables[vkey]);",
          "                    }",
          "                    return ret;",
          "                },",
          "                RegexOptions.IgnorePatternWhitespace);",
          "",
          "                using(var wmap = new StreamWriter(_OUTPUT + \".p.map\", false, new UTF8Encoding(false)))",
          "                {",
          "                    string map = string.Empty;",
          "                    foreach(var v in variables) map += string.Format(\"{0}={1}{2}\", v.Value, v.Key, Environment.NewLine);",
          "                    wmap.Write(map);",
          "                }",
          "                ",
          "                // We'll work without double quotes, so we should define all pairs of \"...\" per line",
          "",
          "                var strings = scalc(content);",
          "",
          "                // Now, we should split long strings",
          "",
          "                var lines = new List<string>();",
          "                bool zipTargets = false;",
          "                ",
          "                // Protecting from some symbols in zero position via moving to the end of the previous line",
          "                Action<int, int> safeAdd = (idx, l) =>",
          "                {",
          "                    int lofs = idx;",
          "                    while( (content[lofs] == ' ' || content[lofs] == ')' || content[lofs] == '=')",
          "                           ||",
          "                           //TODO: lexemes via vars %a%, %ab%, ... + escaped %%data",
          "                           (content[lofs] == '%' || content[Math.Min(lofs + 1, content.Length - 1)] == '%') ",
          "                        )",
          "                    {",
          "                        ++lofs;",
          "                    }",
          "",
          "                    int ofsdelta = lofs - idx;",
          "                    if(ofsdelta > 0)",
          "                    {",
          "                        lines[lines.Count - 1] += content.Substring(idx, ofsdelta);",
          "                        lines.Add(content.Substring(lofs, l - ofsdelta));",
          "                        return;",
          "                    }",
          "",
          "                    lines.Add(content.Substring(idx, l));",
          "                };",
          "",
          "                for(int i = 0, len = $(packmaxline); i < content.Length; i += len)",
          "                {",
          "                    int rlen = Math.Min(content.Length - i, len);",
          "                    int rpos = i + rlen;",
          "",
          "                    bool added = false;",
          "                    foreach(var ifq in strings)",
          "                    {",
          "                        // Protect strings that we saw above",
          "                        if(rpos >= ifq.Key && rpos <= ifq.Key + ifq.Value)",
          "                        {",
          "                            int repos = ((ifq.Key + ifq.Value) - rpos);",
          "",
          "                            safeAdd(i, rlen + repos);",
          "                            i += repos;",
          "",
          "                            added = true;",
          "                            break;",
          "                        }",
          "                    }",
          "",
          "                    if(added) {",
          "                        continue;",
          "                    }",
          "",
          "                    // Protecting from escaped chars as ^ + char above",
          "",
          "                    int esc = rpos - 1; // the end of the previous line that should be checked on `^` char",
          "                    if(content.Length > esc && content[esc] == '^') {",
          "                        rlen += 1;",
          "                        safeAdd(i, rlen);",
          "                        i += 1;",
          "                        continue;",
          "                    }",
          "                    ",
          "                    safeAdd(i, rlen);",
          "                }",
          "",
          "                // extra zip for lines",
          "",
          "                var zipped = new List<KeyValuePair<bool, string>>();",
          "                foreach(string line in lines)",
          "                {",
          "                    Match m = Regex.Match(line, string.Format(@\"(^.+/PropertyGroup\\^>)(.+?)(\\^<{0}+?Task.+)\", chValidInBat));",
          "                    if(!m.Success) { zipped.Add(new KeyValuePair<bool, string>(false, line)); continue; }",
          "",
          "                    zipTargets = true;",
          "",
          "                    var defTargets = new List<string>();",
          "                    string tagTarget = null, tagTask = null, attrTask = null;",
          "                    foreach(Match _t in Regex.Matches",
          "                    (",
          "                        m.Groups[2].Value,",
          "                        string.Format(@\"\\^<({0}+?)\\s*Name=\"\"({0}+?)\"\"\\^>\\s*\\^<({0}+?)\\s+({0}+?)\\s*=\", chValidInBat)",
          "                    ))",
          "                    {",
          "                        tagTarget   = _t.Groups[1].Value;",
          "                        tagTask     = _t.Groups[3].Value;",
          "                        attrTask    = _t.Groups[4].Value;",
          "                        ",
          "                        defTargets.Add(_t.Groups[2].Value);",
          "                    }",
          "",
          "                    zipped.Add(new KeyValuePair<bool, string>(false, m.Groups[1].Value));",
          "                    zipped.Add(new KeyValuePair<bool, string>",
          "                    (   ",
          "                        true,",
          "                        string.Format(\"for %%t in ({0})do <nul set/P=^<{1} Name=\\\"%%t\\\"^>^<{2} {3}=\\\"%%t\\\"/^>^</{1}^>\",",
          "                            string.Join(\",\", defTargets.ToArray()),",
          "                            tagTarget,",
          "                            tagTask,",
          "                            attrTask",
          "                    )));",
          "                    zipped.Add(new KeyValuePair<bool, string>(false, m.Groups[3].Value));",
          "                }",
          "                if(!zipTargets)",
          "                {",
          "                    Console.ForegroundColor = ConsoleColor.Yellow;",
          "                    Console.WriteLine(\"[Warn] Targets are not compressed.\");",
          "                    Console.ResetColor();",
          "                }",
          "",
          "                // extractor",
          "",
          "                const string corevar    = \"tgnt\";",
          "                content                 = string.Empty;",
          "",
          "                foreach(var line in zipped)",
          "                {",
          "                    string ldata = string.Format",
          "                    (",
          "                        \"{0}{1}>>%{2}%\\r\\n\",",
          "                        line.Key ? string.Empty : \"<nul set/P=\", line.Value, corevar",
          "                    );",
          "",
          "                    if(ldata.Length >= 2047) {",
          "                        Console.WriteLine(\"[Warn] Length of line {0}\", ldata.Length);",
          "                    }",
          "                    else if(ldata.Length >= 8191) {",
          "                        Console.Error.WriteLine(\"[Error] Length of line {0}\", ldata.Length);",
          "                    }",
          "                    ",
          "                    content += ldata;",
          "                }",
          "",
          "                if(defSchemasVar.Key != null)",
          "                    content = content.Replace(defSchemasVar.Value, \"%\" + defSchemasVar.Key + \"%\");",
          "",
          "                // definition of lexemes",
          "",
          "                content = defv.Substring(0, defv.Length - 1) + \"\\r\\n\" + content;",
          "",
          "                // Finally, format script to work with gnt.core",
          "",
          "                using(var tplreader = new StreamReader(_EMBDTPL, System.Text.Encoding.UTF8, true))",
          "                {",
          "                    content = tplreader.ReadToEnd()",
          "                                .Replace(\"$gnt.core.logic$\", content)",
          "                                .Replace(\"$tpl.corevar$\", corevar);",
          "                }",
          "",
          "                // ",
          "",
          "                using(var writer = new StreamWriter(_OUTPUT, false, new UTF8Encoding(false))) { // do not use BOM ! it failed with initial signature",
          "                    writer.Write(content);",
          "                }",
          "                Console.WriteLine(\"{0} -> {1}\", _CORE, _OUTPUT);",
          "            }",
          "            ",
          "            return 0;",
          "        }",
          "    }",
          "}"
        ]
      }
    },
    {
      "Enabled": false,
      "Name": "CompressorEmbd",
      "Caption": ".compressor at /embedded",
      "SupportSBEScripts": false,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeCSharp, vsSolutionBuildEvent",
        "Type": "CSharp",
        "References": [
          "System.dll",
          "System.Core.dll"
        ],
        "SmartReferences": true,
        "GenerateInMemory": true,
        "TreatWarningsAsErrors": false,
        "WarningLevel": 4,
        "FilesMode": false,
        "CachingBytecode": false,
        "Command__": [
          "/*",
          "*   Copyright (c) 2015  Denis Kuzmin <x-3F@outlook.com> github/3F",
          "*",
          "*   Licensed under the GetNuTool license",
          "*   https://github.com/3F/GetNuTool",
          "*",
          "*   Based on compressor from hMSBuild project",
          "*   https://github.com/3F/hMSBuild",
          "*/",
          "",
          "using System;",
          "using System.Collections.Generic;",
          "using System.IO;",
          "using System.Linq;",
          "using System.Text;",
          "using System.Text.RegularExpressions;",
          "using ICommand = net.r_eg.vsSBE.Actions.ICommand;",
          "using ISolutionEvent = net.r_eg.vsSBE.Events.ISolutionEvent;",
          "",
          "namespace vsSolutionBuildEvent",
          "{",
          "    public class CSharpMode",
          "    {",
          "        public static int Init(ICommand cmd, ISolutionEvent evt)",
          "        {",
          "            const string _CORE = @\"$(_batInput)\";",
          "            const string _OUTPUT = @\"$(_batOutput)\";",
          "            const int _CDICT_SHIFT = $(_cdictShift);",
          "",
          "            Func<char[], int, Func<int, bool>, string[]> gencomb = (_dict, _size, _rule0) =>",
          "            {",
          "                var combination = new char[_size];",
          "                var set = new List<string>((int)Math.Pow(_dict.Length, _size));",
          "",
          "                int pos = 0;",
          "                Action generator = null;",
          "                generator = () =>",
          "                {",
          "                    for(int i = 0, lim = _size - 1; i < _dict.Length; ++i)",
          "                    {",
          "                        if(pos == 0 && !_rule0(i)) continue;",
          "",
          "                        if(pos < lim)",
          "                        {",
          "                            combination[pos] = _dict[i];",
          "                            ++pos;",
          "                            generator();",
          "                            --pos;",
          "                        }",
          "                        else",
          "                        {",
          "                            combination[pos] = _dict[i];",
          "                            set.Add(new String(combination.ToArray()));",
          "                        }",
          "                    }",
          "                };",
          "",
          "                generator();",
          "                return set.ToArray();",
          "            };",
          "",
          "            Func<string, string> review = (input) =>",
          "            {",
          "                /* predefined parser behaviour */",
          "                input = Regex.Replace(input, @\"\\s*::&:\\s*&?\", \"\\r\\n\");",
          "",
          "                //~ finalization",
          "                input = Regex.Replace(input, @\"(@echo off)\\s*&\\s*echo.*?exit\\s*/B\\s*\\d+\", \"$1\");",
          "                input = Regex.Replace(input, @\"(@echo off)\\r\\n\", \"$1&\", RegexOptions.IgnoreCase);",
          "                input = input.TrimEnd('&', '\\r', '\\n', ' ');",
          "",
          "                return input;",
          "            };",
          "",
          "            var variables = new Dictionary<string, string>();",
          "            UTF8Encoding utf8noId = new UTF8Encoding(false);",
          "",
          "            var _cdict = new[]",
          "            {",
          "                'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',",
          "                'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',",
          "                'y', 'z', 'a', 'b', 'c', 'd', '0', '1', '2', '3',",
          "                '4', '5', '6', '7', '8', '9',",
          "                // '_'",
          "            };",
          "",
          "            var cdict = _cdict.Skip(_CDICT_SHIFT).Concat(_cdict.Take(_CDICT_SHIFT)).ToArray();",
          "",
          "            string[] vdict = gencomb(cdict, 2, (i) => { return char.IsLetter(cdict[i]) || cdict[i] == '_'; });",
          "",
          "            // to skip processing for:",
          "            var exvar = new[] { \"__p_call\", \"__p_msb\", \"GetNuTool\", \"debug\", \"install\", \"run\", \"touch\" };",
          "",
          "            const string VNAME = \"[a-z_][a-z_0-9]+\";",
          "            using(var reader = new StreamReader(_CORE, Encoding.UTF8, true))",
          "            {",
          "                string content = reader.ReadToEnd()",
          "                        .Replace(\"\\r\\n\", \"\\n\").Replace(\"\\n\", \"\\r\\n\") // F-148",
          "                        .Replace(\"$core.version$\", \"$(pVer)\")",
          "                        .Replace(\"$app.version$\", \"$(pVerPrintApp)\");",
          "",
          "                /* set /a ERROR_ codes */",
          "",
          "                var errorsCodes = new Dictionary<string, string>();",
          "                content = Regex.Replace",
          "                (",
          "                    content,",
          "                    @\"set\\s+\\/a\\s+(?'k'ERROR_[^= ]+)\\s*=\\s*(?'v'\\d+)\",",
          "                    (m) =>",
          "                    {",
          "                        errorsCodes[m.Groups[\"k\"].Value] = m.Groups[\"v\"].Value;",
          "                        return string.Empty;",
          "                    }",
          "                );",
          "",
          "                foreach(var err in errorsCodes)",
          "                {",
          "                    content = Regex.Replace(",
          "                        content,",
          "                        string.Format(\"({1}{0}{1}|{2}{0}{2})\", err.Key, \"%\", \"!\"),",
          "                        err.Value",
          "                    );",
          "                }",
          "",
          "",
          "                /* Shorten variables & labels */",
          "",
          "                uint uniqVars = 0;",
          "                content = Regex.Replace",
          "                (",
          "                    content,",
          "                    @\"(?'def' ",
          "                        set\\s+?",
          "                         (?:\\/\\S\\s+?)?",
          "                         (?:\"\"\\s*?)?",
          "                      )",
          "                      (?'name'\" + VNAME + @\")",
          "                      (?'lim'\\s?\\S?=)\", // aq+=1,.. TODO: aq=aq+1 ; aq=1+aq ...",
          "                    (m) =>",
          "                    {",
          "                        var def     = m.Groups[\"def\"].Value;",
          "                        var vname   = m.Groups[\"name\"].Value;",
          "                        var lim     = m.Groups[\"lim\"].Value;",
          "",
          "                        if(exvar.Contains(vname))",
          "                        {",
          "                            return m.Groups[0].Value;",
          "                        }",
          "",
          "                        if(variables.ContainsKey(vname))",
          "                        {",
          "                            return def + variables[vname] + lim;",
          "                        }",
          "",
          "                        if(uniqVars + 1 > vdict.Length)",
          "                        {",
          "                            throw new OverflowException(\"vdict does not contain data for new vars\");",
          "                        }",
          "                        variables[vname] = vdict[uniqVars++];",
          "                        return def + variables[vname] + lim;",
          "                    },",
          "                    RegexOptions.IgnorePatternWhitespace | RegexOptions.IgnoreCase",
          "                );",
          "",
          "                // call :proc p1 p2 ...",
          "                content = Regex.Replace",
          "                (",
          "                    content,",
          "                    @\"(?'def'call\\s+:\" + VNAME + @\"\\s)(?'args'.+?)(?'eol'&|\\||\\r\\n)\",",
          "                    (m) =>",
          "                    {",
          "                        var def     = m.Groups[\"def\"].Value;",
          "                        var cargs   = m.Groups[\"args\"].Value;",
          "                        var eol     = m.Groups[\"eol\"].Value;",
          "",
          "                        return def + Regex.Replace",
          "                        (",
          "                            cargs,",
          "                            @\"(?'split'^|\\s)(?:(?'str'\"\".+?\"\")|(?'name'\" + VNAME + \"))\",",
          "                            (_m) =>",
          "                            {",
          "                                var split = _m.Groups[\"split\"].Value;",
          "",
          "                                if(_m.Groups[\"str\"].Success)",
          "                                {",
          "                                    return split + _m.Groups[\"str\"].Value;",
          "                                }",
          "",
          "                                var vname = _m.Groups[\"name\"].Value;",
          "",
          "                                if(exvar.Contains(vname))",
          "                                {",
          "                                    return split + vname;",
          "                                }",
          "",
          "                                if(variables.ContainsKey(vname))",
          "                                {",
          "                                    return split + variables[vname];",
          "                                }",
          "",
          "                                if(uniqVars + 1 > vdict.Length)",
          "                                {",
          "                                    throw new OverflowException(\"vdict does not contain data for new vars\");",
          "                                }",
          "                                variables[vname] = vdict[uniqVars++];",
          "                                return split + variables[vname];",
          "                            },",
          "                            RegexOptions.IgnoreCase | RegexOptions.Multiline",
          "                        ) + eol;",
          "                    },",
          "                    RegexOptions.IgnoreCase",
          "                );",
          "",
          "                // %name... & !name...",
          "                content = Regex.Replace",
          "                (",
          "                    content,",
          "                    @\"(?'def'(?:[%!]|\\sdefined\\s+))(?'name'\" + VNAME + \")\",",
          "                    (m) =>",
          "                    {",
          "                        var def     = m.Groups[\"def\"].Value;",
          "                        var vname   = m.Groups[\"name\"].Value;",
          "",
          "                        if(!variables.ContainsKey(vname))",
          "                        {",
          "                            return def + vname;",
          "                        }",
          "                        return def + variables[vname];",
          "                    },",
          "                    RegexOptions.IgnoreCase",
          "                );",
          "",
          "                // labels",
          "                content = Regex.Replace",
          "                (",
          "                    content,",
          "                    @\"(?'def'call\\s*:|^\\s*:|goto\\s*:?)(?'label'\" + VNAME + @\")(?'eol'\\s|&|\\r\\n)\",",
          "                    (m) =>",
          "                    {",
          "                        var def     = m.Groups[\"def\"].Value;",
          "                        var label   = m.Groups[\"label\"].Value;",
          "                        var eol     = m.Groups[\"eol\"].Value;",
          "",
          "                        if(exvar.Contains(label))",
          "                        {",
          "                            return def + label + eol;",
          "                        }",
          "",
          "                        if(variables.ContainsKey(label))",
          "                        {",
          "                            return def + variables[label] + eol;",
          "                        }",
          "",
          "                        if(uniqVars + 1 > vdict.Length)",
          "                        {",
          "                            throw new OverflowException(\"vdict does not contain data for new labels\");",
          "                        }",
          "                        variables[label] = vdict[uniqVars++];",
          "                        return def + variables[label] + eol;",
          "                    },",
          "                    RegexOptions.IgnoreCase | RegexOptions.Multiline",
          "                );",
          "",
          "",
          "                /* exit/B */",
          "",
          "                content = Regex.Replace(content, @\"exit\\s*(?:\\/B\\s*?(?'code'\\d+|(?:!|%)\" +VNAME+ @\"(?:!|%)?)|\\/B)\\s*?\", (m) =>",
          "                {",
          "                    string ret  = \"exit/B\";",
          "                    string code = m.Groups[\"code\"].Value;",
          "",
          "                    if(m.Groups[\"code\"].Success)",
          "                    {",
          "                        // 'exit /B 0' is not equal to 'exit /B' - it will pass the latest raised code i.e. without changing it.",
          "                        return ret + code;",
          "                    }",
          "                    return ret;",
          "                },",
          "                RegexOptions.IgnoreCase);",
          "",
          "                content = Regex.Replace(content, @\"\\s*(&+)\\s*(exit/B)\", \"$1$2\");",
          "",
          "                /* pseudo arguments from labels */",
          "",
          "                content = Regex.Replace(content, @\"^\\s*(?'label':\" + VNAME + @\").*?\\r\\n\", (m) =>",
          "                {",
          "                    return m.Groups[\"label\"].Value + \"\\r\\n\";",
          "                },",
          "                RegexOptions.IgnoreCase | RegexOptions.Multiline);",
          "",
          "",
          "                /* comments */",
          "",
          "                content = Regex.Replace(content, @\"(^\\s*?(?'l'::!|rem|::)\\s+)(?'d'.*?)\\r\\n\", (m) =>",
          "                {",
          "                    if(m.Groups[\"l\"].Value == \"::!\" /*|| m.Groups[\"d\"].Value.StartsWith(\"Copyright \")*/) return m.Value;",
          "",
          "                    return string.Empty;",
          "                },",
          "                RegexOptions.IgnoreCase | RegexOptions.Multiline);",
          "",
          "",
          "                /* syntax */",
          "",
          "                content = Regex.Replace(content, @\"(\\r\\n)\\s*\", \"$1\");",
          "                content = Regex.Replace(content, @\"\\s+(\\r\\n)\", \"$1\");",
          "                content = content.Replace(\"\\r\\n)\", \")\");",
          "                content = content.Replace(\"(\\r\\n\", \"(\");",
          "",
          "                Func<string, string> InlineBlocksIf = null;",
          "                InlineBlocksIf = (input) =>",
          "                {",
          "                    if(input.IndexOfAny(new[] { '(', ')' }) == -1) return null;",
          "                    return Regex.Replace",
          "                    (",
          "                        input,",
          "                        @\"",
          "                        (?'lim'^|\\r\\n|[\\s)&])",
          "                        (?'cond'else\\s.*|if\\s.+?(?!\\(x86\\).+?))",
          "                        \\((?'body'",
          "                            (?>",
          "                                [^\\(\\)]",
          "                            |",
          "                                \\((?<R>)",
          "                            |",
          "                                \\)(?<-R>)",
          "                            )*",
          "                            (?(R)(?!))",
          "                        )\\)",
          "                        \",",
          "                        (_m) =>",
          "                        {",
          "                            string lim  = _m.Groups[\"lim\"].Value;",
          "                            string cond = _m.Groups[\"cond\"].Value;",
          "                            string body = _m.Groups[\"body\"].Value;",
          "",
          "                            string ret = InlineBlocksIf(_m.Groups[\"body\"].Value);",
          "                            if(ret == null) return lim + \"(\" + cond + \"(\" + body + \"))&\";",
          "",
          "                            return lim + \"(\" + cond + \"(\" + ret + \"))&\";",
          "                        },",
          "                        RegexOptions.IgnorePatternWhitespace",
          "                    );",
          "                };",
          "                //content = InlineBlocksIf(content);",
          "                content = Regex.Replace(content, @\"\\)\\s*&\\s*\\(\\s*else\\s\", \"else \");",
          "                content = Regex.Replace(content, @\"\\)\\s*&\\s*\\)\", \"))\");",
          "                content = Regex.Replace(content, @\"\\)\\s*&\\s*\\r\\n\", \")\\r\\n\");",
          "",
          "                content = Regex.Replace",
          "                (",
          "                    content,",
          "                    @\"(^(?:setlocal|endlocal|rmdir|shift|call|exit|echo|del|goto|set)[:/\\w\\S ]*)\\r\\n(?![:<])\",",
          "                    (_m) =>",
          "                    {",
          "                        if(_m.Value.IndexOfAny(new[] { '&', '|' }) != -1) return _m.Value;",
          "                        return _m.Groups[1].Value + \"&\";",
          "                    },",
          "                    RegexOptions.Multiline | RegexOptions.IgnoreCase",
          "                );",
          "                // GetNuTool, Y-84",
          "                content = Regex.Replace(content, @\"(?<!\\*)&(setlocal\\s.+?DelayedExpansion)\", \"\\r\\n$1\", RegexOptions.IgnoreCase);",
          "",
          "                // hMSBuild, Y-50",
          "                content = Regex.Replace(content, @\"(setlocal\\s.+?DelayedExpansion)&@echo off\", \"$1\", RegexOptions.IgnoreCase);",
          "",
          "                content = Regex.Replace(content, @\"\\)\\s*\\r\\n\\s*\\(\", \")&(\");",
          "",
          "                content = Regex.Replace(content, @\"\\s+in\\s*\\(([0-9., ]*?)\\)\\s*do\\s*(\\()?\", (mfor) =>",
          "                {",
          "                    return string.Format(\" in ({0})do {1}\", mfor.Groups[1].Value.Replace(\" \", \"\"), mfor.Groups[2].Value);",
          "                },",
          "                RegexOptions.IgnoreCase);",
          "                content = Regex.Replace(content, @\"(?<![\"\"'])\\)\\s+?(do (?:\\(set |2?>nul))\", \")$1\");",
          "",
          "                content = Regex.Replace(content, @\"\\s*\\)\\s*(else\\s)\", \")$1\");",
          "                content = Regex.Replace(content, @\"\\(\\s+(if|for|echo|goto|set|call)\\s+\", \"($1 \");",
          "                content = Regex.Replace(content, @\"\\s*&\\s*(\\()?\\s*(if|for|echo|goto|call)\\s+\", \"&$1$2 \");",
          "",
          "                // arithmetic and predefined expressions",
          "                content = Regex.Replace(content, @\"(set)\\s+?/a\\s?\", \"$1/a\", RegexOptions.IgnoreCase);",
          "                content = Regex.Replace(content, @\"(NUMBER_OF_PROCESSORS)\\s*([\\-+/*]{1})\\s*(\\d+)\", \"$1$2$3\");",
          "",
          "                Func<string, string> InlineBlocksFor = null;",
          "                InlineBlocksFor = (input) =>",
          "                {",
          "                    return Regex.Replace",
          "                    (",
          "                        input,",
          "                        @\"",
          "                        (?'lim'^|\\r\\n|[\\s)&])",
          "                        (?'def'for\\s[^(]+?\\([^)]+?\\)\\s*do\\s*)",
          "                        \\((?'body'",
          "                            (?>",
          "                                [^\\(\\)]",
          "                            |",
          "                                \\((?<R>)",
          "                            |",
          "                                \\)(?<-R>)",
          "                            )*",
          "                            (?(R)(?!))",
          "                        )\\)",
          "                        \\s*&?",
          "                        \",",
          "                        (_m) =>",
          "                        {",
          "                            string lim  = _m.Groups[\"lim\"].Value;",
          "                            string def  = _m.Groups[\"def\"].Value;",
          "                            string body = _m.Groups[\"body\"].Value;",
          "",
          "                            return lim + \"(\" + def + \"(\" + body + \"))&\";",
          "                        },",
          "                        RegexOptions.IgnorePatternWhitespace",
          "                    );",
          "                };",
          "                //content = InlineBlocksFor(content);",
          "                //content = Regex.Replace(content, @\"\\)\\s*&\\s*:\", \")\\r\\n:\");",
          "",
          "",
          "                /* line packing */",
          "",
          "                Func<string, int, string, string> splitLongLines = (input, lim, wrd) =>",
          "                {",
          "                    var spl = new StringBuilder(content.Length + 100);",
          "                    for(int i = 0; i < content.Length;)",
          "                    {",
          "                        int start = i;",
          "                        int end = content.IndexOf(\"\\r\\n\", start + 1);",
          "                        if(end == -1)",
          "                        {",
          "                            spl.Append(content.Substring(start));",
          "                            break;",
          "                        }",
          "                        i = end;",
          "",
          "                        int len = end - start;",
          "                        if(len <= lim)",
          "                        {",
          "                            spl.Append(content.Substring(start, len));",
          "                            continue;",
          "                        }",
          "",
          "                        int pos = content.IndexOf(wrd, start + lim - wrd.Length);",
          "                        if(pos == -1)",
          "                        {",
          "                            spl.Append(content.Substring(start, end - start));",
          "                            continue;",
          "                        }",
          "",
          "                        string a = content.Substring(start, pos - start);",
          "                        spl.AppendLine(a);",
          "                        string b = content.Substring(++pos, end - pos);",
          "                        spl.Append(b);",
          "                    }",
          "                    return spl.ToString();",
          "                };",
          "                // max 2047 or 8191 (XP+) characters per line",
          "                //content = splitLongLines(content, 1700, \"&echo\");",
          "",
          "                using(var writer = new StreamWriter(_OUTPUT, false, utf8noId))",
          "                writer.Write(review(content));",
          "",
          "                Console.WriteLine(\"{0} -> {1}\", _CORE, _OUTPUT);",
          "            }",
          "",
          "            //File.WriteAllText(_CORE, review(File.ReadAllText(_CORE, Encoding.UTF8)), utf8noId);",
          "",
          "            /* map */",
          "",
          "            using(var wmap = new StreamWriter(_OUTPUT + \".map\", false, utf8noId))",
          "            {",
          "                string map = string.Empty;",
          "                foreach(var v in variables) map += string.Format(\"{0}={1}{2}\", v.Value, v.Key, Environment.NewLine);",
          "                wmap.Write(map);",
          "            }",
          "",
          "            string mtpl =",
          "@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>",
          "<Project ToolsVersion=\"\"4.0\"\" xmlns=\"\"http://schemas.microsoft.com/developer/msbuild/2003\"\">",
          "  <Target Name=\"\"vmap\"\">",
          "{0}",
          "  </Target>",
          "</Project>\";",
          "",
          "            using(var wmap = new StreamWriter(_OUTPUT + \".map.targets\", false, utf8noId))",
          "            {",
          "                string map = string.Empty;",
          "                foreach(var v in variables)",
          "                {",
          "                    map += string.Format",
          "                    (",
          "                        \"<CreateProperty Value=\\\"{0}({1})\\\"><Output TaskParameter=\\\"Value\\\" PropertyName=\\\"{2}\\\"/></CreateProperty>{3}\",",
          "                        \"$\",",
          "                        v.Value,",
          "                        v.Key,",
          "                        Environment.NewLine",
          "                    );",
          "                }",
          "                wmap.Write(string.Format(mtpl, map));",
          "            }",
          "",
          "            return 0;",
          "        }",
          "    }",
          "}"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "PackBat",
      "IgnoreIfBuildFailed": true,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[$(_batInput = $(fPacked))]",
          "#[$(_batOutput = $(fPackMin))]",
          "#[$(_cdictShift = '0')]",
          "#[Core events.Pre.item(\"CompressorEmbd\").run()]",
          "",
          "#[$(_batInput = 'svc.gnt.bat')]",
          "#[$(_batOutput = 'obj\\svc.gnt.bat')]",
          "#[$(_cdictShift = '11')]",
          "#[Core events.Pre.item(\"CompressorEmbd\").run()]"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "TuningEmbd",
      "SupportSBEScripts": false,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeCSharp, vsSolutionBuildEvent",
        "Type": "CSharp",
        "References": [
          "System.dll",
          "System.Core.dll"
        ],
        "SmartReferences": true,
        "GenerateInMemory": true,
        "TreatWarningsAsErrors": false,
        "WarningLevel": 4,
        "FilesMode": false,
        "CachingBytecode": false,
        "Command__": [
          "using System.IO;",
          "using System.Text;",
          "using System.Text.RegularExpressions;",
          "using ICommand = net.r_eg.vsSBE.Actions.ICommand;",
          "using ISolutionEvent = net.r_eg.vsSBE.Events.ISolutionEvent;",
          "",
          "namespace vsSolutionBuildEvent",
          "{",
          "    public class CSharpMode",
          "    {",
          "        public static int Init(ICommand cmd, ISolutionEvent evt)",
          "        {",
          "            const string _MCORE = @\"$(fPackMin)\";",
          "            UTF8Encoding utf8noId = new UTF8Encoding(false);",
          "",
          "            var reader = new StreamReader(_MCORE, utf8noId, true);",
          "                string content = reader.ReadToEnd();",
          "            reader.Dispose();",
          "",
          "            string defvGetNuTool = null;",
          "            content = Regex.Replace(content, @\"&set (.){1}=GetNuTool\", (m) =>",
          "            {",
          "                defvGetNuTool = m.Groups[1].Value;",
          "                return string.Empty;",
          "            });",
          "",
          "            var defv = new StringBuilder();",
          "",
          "            if(defvGetNuTool != null)",
          "            {",
          "                content = content.Replace(\"GetNuTool\", \"%\"+ defvGetNuTool +\"%\");",
          "                defv.Append(\"&set \"+ defvGetNuTool +\"=GetNuTool\");",
          "            }",
          "",
          "            // F-147",
          "            content = content.Replace(\"MSBuild\", \"%_0%\");",
          "            content = Regex.Replace(content, @\"(enableDelayedExpansion)\", \"$1&set _0=MSBuild\");",
          "",
          "            content = content.Replace(\"Reference Include=\\\"\", \"%_1%\");",
          "            content = Regex.Replace(content, @\"^(<nul set/P=>.+)(\\r\\n)\", \"$1&set _1=Reference Include=\\\"$2\", RegexOptions.Multiline);",
          "",
          "            if(defv.Length > 0)",
          "            {",
          "                content = Regex.Replace(content, \"(%random%%random%\\\")\", \"$1\" + defv);",
          "            }",
          "",
          "            using(var writer = new StreamWriter(_MCORE, false, utf8noId))",
          "                writer.Write(content.Replace(\"\\r\\n\", \"\\n\")); // F-148",
          "",
          "            return 0;",
          "        }",
          "    }",
          "}"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "Validating",
      "Caption": "Validating cores ...",
      "IgnoreIfBuildFailed": true,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[IO copy.file(\"$(dobj)gnt.bat\", \"$(dobj)gnt.full.bat\", true)]",
          "#[IO copy.file(\"$(dobj)gnt.minified.bat\", \"$(dobj)gnt.bat\", true)]",
          "#[IO delete.files({\"$(dobj)gnt.minified.bat\"})]",
          "",
          "#[IO writeLine(STDOUT):#[File cmd(\"cd $(dobj) & .\\gnt.bat -unpack\", 400)]]",
          "",
          "#[var hCore1 = #[Func hash.SHA1(\"$([System.IO.File]::ReadAllText('$(dobj)gnt.min.core'))\")]]",
          "#[var hCore2 = #[Func hash.SHA1(\"$([System.IO.File]::ReadAllText('$(dobj)gnt.core'))\")]]",
          "",
          "#[IO writeLine(STDOUT):",
          "Core 1: 0x#[$(hCore1)] : gnt.min.core",
          "Core 2: 0x#[$(hCore2)] : gnt.core",
          "]",
          "",
          "#[( \"$(hCore1)\" != \"$(hCore2)\" )",
          "{",
          "    #[IO writeLine(STDERR): Core 1 != Core 2]",
          "    #[Build cancel = true]",
          "}]",
          ""
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "CsEdition",
      "Caption": "Generate CS edition ...",
      "SupportSBEScripts": false,
      "IgnoreIfBuildFailed": true,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeCSharp, vsSolutionBuildEvent",
        "Type": "CSharp",
        "References": [
          "System.dll"
        ],
        "SmartReferences": true,
        "GenerateInMemory": true,
        "TreatWarningsAsErrors": false,
        "WarningLevel": 4,
        "FilesMode": false,
        "CachingBytecode": false,
        "Command__": [
          "using System.Collections.Generic;",
          "using System.Text;",
          "using System.Text.RegularExpressions;",
          "using System.IO;",
          "using ICommand = net.r_eg.vsSBE.Actions.ICommand;",
          "using ISolutionEvent = net.r_eg.vsSBE.Events.ISolutionEvent;",
          "",
          "namespace vsSolutionBuildEvent",
          "{",
          "    public class CSharpMode",
          "    {",
          "        public static int Init(ICommand cmd, ISolutionEvent evt)",
          "        {",
          "            string core = File.ReadAllText(@\"$(dobj)gnt.min.core\");",
          "            string csharp = File.ReadAllText(\"csharp.cs\");",
          "",
          "            var sb = new StringBuilder(\"// GetNuTool $(pVerPrintApp) for C# //\");",
          "",
          "            sb.AppendLine()",
          "                .AppendLine(Regex.Match(csharp, @\"^/\\*!.+?\\*/\", RegexOptions.Singleline).Groups[0].Value)",
          "                .AppendLine();",
          "",
          "            foreach(Match m in Regex.Matches(core, @\"Using Namespace=\"\"([a-z_0-9.]+)\"\"\", RegexOptions.IgnoreCase))",
          "            {",
          "                sb.AppendLine(\"using \" + m.Groups[1].Value + \";\");",
          "            }",
          "",
          "            var pDefault = new Dictionary<string, string>() { {\"wpath\", \"\"} };",
          "            foreach(Match m in Regex.Matches",
          "            (",
          "                Regex.Match(core, @\"PropertyGroup>(.+?)</PropertyGroup\", RegexOptions.IgnoreCase).Groups[1].Value,",
          "                @\"<\\s*([a-zA-Z_0-9]+)\\s*(?:>|.+?>)([^<]+?)<\"",
          "            ))",
          "            {",
          "                if(!pDefault.ContainsKey(m.Groups[1].Value))",
          "                    pDefault[m.Groups[1].Value] = m.Groups[2].Value;",
          "            }",
          "",
          "            string cs = Regex.Match(core, @\"<!\\[CDATA\\[(.+)\\]\\]>\", RegexOptions.IgnoreCase).Groups[1].Value;",
          "",
          "            var props = new List<string>();",
          "            int tmodeIndex = cs.IndexOf(\"@\\\"$(wpath\"); // Global Properties before tmode use.",
          "            int globalProps = 0;",
          "            cs = Regex.Replace(cs, @\"@?\"\"\\s*\\$\\(([a-zA-Z_0-9.]+)\\)\\s*\"\"\", (m) =>",
          "            {",
          "                if(m.Groups[1].Index < tmodeIndex) globalProps = props.Count;",
          "                string name = m.Groups[1].Value;",
          "                if(name == \"GetNuTool\") return m.Value;",
          "                if(name == \"break\") name = \"@\" + name;",
          "                if(!props.Contains(name)) props.Add(name);",
          "                return name;",
          "            })",
          "            .Replace(\"$$(GetNuTool)\", \"$(pVerPrintApp)\");",
          "",
          "            cs = Regex.Replace(cs, @\"Environment\\.CurrentDirectory\\s*=[^;]+?;\", string.Empty);",
          "            cs = Regex.Replace(cs, @\"=(\\s*[a-z0-9A-Z_]+\\s*\\([a-z0-9A-Z_]+\\)\\s*\\?\\?\\s*)MSBuildProjectDirectory;\", \"=$1Environment.CurrentDirectory;\");",
          "",
          "            var fields = new StringBuilder();",
          "            for(int i = 0; i <= globalProps; ++i)",
          "            {",
          "                string p = props[i];",
          "                string pv = pDefault.ContainsKey(p) ? pDefault[p] : string.Empty;",
          "                fields.AppendLine(string.Format",
          "                (",
          "                    \"        public string {0}{1} = {2}\\\"{3}\\\";\",",
          "                    p == \"break\" ? \"@\" : \"\",",
          "                    p,",
          "                    pv.Contains(@\"\\\") ? \"@\" : \"\",",
          "                    pv",
          "                ));",
          "            }",
          "",
          "            cs = cs.Replace(\"Console.Write\", \"StdOut\")",
          "                   .Replace(\"Console.Error.Write\", \"StdErr\");",
          "",
          "            var margs = new StringBuilder();",
          "            for(int i = globalProps + 1; i < props.Count; ++i)",
          "            {",
          "                string p = props[i];",
          "                string pv = pDefault.ContainsKey(p) ? pDefault[p] : string.Empty;",
          "                ",
          "                if(p == \"MSBuildProjectDirectory\") continue;",
          "                margs.Append(string.Format",
          "                (",
          "                    \"string {0}{1} = {2}\\\"{3}\\\", \",",
          "                    p == \"break\" ? \"@\" : \"\",",
          "                    p,",
          "                    pv.Contains(@\"\\\") ? \"@\" : \"\",",
          "                    pv",
          "                ));",
          "            }",
          "",
          "            sb.AppendLine();",
          "            sb.AppendLine(\"namespace io.github._3F\");",
          "            sb.AppendLine(\"{\");",
          "            sb.AppendLine(\"    public class GetNuTool\");",
          "            sb.AppendLine(\"    {\");",
          "            sb.AppendLine(\"#pragma warning disable//netfx4.0+\");",
          "            sb.AppendLine(\"        public const string VER = \\\"$(pVer)\\\";\");",
          "            sb.AppendLine(fields.ToString());",
          "            sb.AppendLine(\"        public virtual void StdOut(string msg, params object[] args) { Console.Write(msg, args); }\");",
          "            sb.AppendLine(\"        public virtual void StdOutLine(string msg = \\\"\\\", params object[] args) { Console.WriteLine(msg, args); }\");",
          "            sb.AppendLine(\"        public virtual void StdErrLine(string msg = \\\"\\\", params object[] args) { Console.Error.WriteLine(msg, args); }\");",
          "            sb.AppendLine();",
          "            sb.AppendLine(\"        /// <param name=\\\"tmode\\\">install / run / touch / grab / pack (create .nupkg) / get (default)</param>\");",
          "            sb.Append(\"        public bool Run(string tmode = \\\"get\\\", \");",
          "            sb.Append(margs.Remove(margs.Length - 2, 2).ToString());",
          "            sb.AppendLine(\"){\" + cs + \"return true;}\");",
          "            sb.AppendLine(\"#pragma warning restore\");",
          "            sb.AppendLine(\"    }\");",
          "            sb.AppendLine(\"}\");",
          "",
          "            using(var w = new StreamWriter(@\"$(dobj)GetNuTool.cs\", false, new UTF8Encoding(false)))",
          "            w.Write(sb.ToString());",
          "            ",
          "            return 0;",
          "        }",
          "    }",
          "}"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "WrapperBatEdition",
      "Caption": "Preapre /wrapper/batch edition",
      "SupportSBEScripts": false,
      "IgnoreIfBuildFailed": true,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeCSharp, vsSolutionBuildEvent",
        "Type": "CSharp",
        "References": [
          "System.dll",
          "System.Core.dll"
        ],
        "SmartReferences": true,
        "GenerateInMemory": true,
        "TreatWarningsAsErrors": false,
        "WarningLevel": 4,
        "FilesMode": false,
        "CachingBytecode": false,
        "Command__": [
          "using System;",
          "using System.IO;",
          "using System.Text;",
          "using System.Text.RegularExpressions;",
          "using ICommand = net.r_eg.vsSBE.Actions.ICommand;",
          "using ISolutionEvent = net.r_eg.vsSBE.Events.ISolutionEvent;",
          "",
          "namespace vsSolutionBuildEvent",
          "{",
          "    public class CSharpMode",
          "    {",
          "        public static int Init(ICommand cmd, ISolutionEvent evt)",
          "        {",
          "            using(var reader = new StreamReader(@\"$(fEmbd)\", System.Text.Encoding.UTF8, true))",
          "            {",
          "                string content = reader.ReadToEnd()",
          "                        .Replace(\"\\r\\n\", \"\\n\").Replace(\"\\n\", \"\\r\\n\") // F-148",
          "                        .Replace(\"/shell/batch edition\", \"/wrapper/batch edition\")",
          "                        .Replace(\"goto unpack\", \"goto off\")",
          "                        .Replace(\":found\", \":off\\r\\n    echo This feature is disabled in current version>&2\\r\\nexit /B %ERROR_CALL_NOT_IMPLEMENTED%\\r\\n\\r\\n:found\");",
          "",
          "                content = Regex.Replace(content, @\"\\s*call :core\\r\\n\", \"\\r\\n\");",
          "                content = Regex.Replace(content, @\"set \\$tpl\\.corevar\\$.+\\r\\n\", \"if not exist %gntcore% goto error\\r\\n\");",
          "                content = Regex.Replace",
          "                (",
          "                    content,",
          "                    @\"echo Engine is not found[^>]+?>\", \":error\\r\\n    echo Engine or %gntcore% is not found. Try other edition or call %gntcore% manually>\"",
          "                );",
          "",
          "                content = Regex.Replace(content, @\"\\s+set EXIT_CODE=!ERRORLEVEL!.+?exit /B !EXIT_CODE!\", \"\\r\\nexit /B !ERRORLEVEL!\", RegexOptions.Singleline);",
          "                content = content.Replace(\"%$tpl.corevar$%\", \"%gntcore%\");",
          "                content = Regex.Replace(content, @\"\\r\\n:unpack.+?exit /B\\s*0\\r\\n\", \"\", RegexOptions.Singleline);",
          "",
          "                content = Regex.Replace(content, @\"(@echo off)\\s*&\\s*echo.*?exit\\s*/B\\s*\\d+\", \"$1\");",
          "",
          "                using(var writer = new StreamWriter(@\"$(fCaller)\", false, new UTF8Encoding(false))) { writer.Write(content); }",
          "            }",
          "            ",
          "            return 0;",
          "        }",
          "    }",
          "}"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "MdToHtml",
      "IgnoreIfBuildFailed": true,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[( $(isPubRel) )",
          "{",
          "    #[IO cmd(\"npx -y --loglevel=error --no-update-notifier markdown-it Readme.md -o obj\\doc.html --linkify --typographer >nul\", 200)]",
          "}]"
        ]
      }
    }
  ],
  "PostBuild": [
    {
      "Enabled": false,
      "Name": "Doc",
      "SupportSBEScripts": false,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeCSharp, vsSolutionBuildEvent",
        "Type": "CSharp",
        "References": [
          "System.dll"
        ],
        "SmartReferences": true,
        "GenerateInMemory": true,
        "TreatWarningsAsErrors": false,
        "WarningLevel": 4,
        "FilesMode": false,
        "CachingBytecode": false,
        "Command__": [
          "using System.IO;",
          "using ICommand = net.r_eg.vsSBE.Actions.ICommand;",
          "using ISolutionEvent = net.r_eg.vsSBE.Events.ISolutionEvent;",
          "",
          "namespace vsSolutionBuildEvent",
          "{",
          "    public class CSharpMode",
          "    {",
          "        public static int Init(ICommand cmd, ISolutionEvent evt)",
          "        {",
          "            File.WriteAllText",
          "            (",
          "                @\"obj\\doc.html\",",
          "                File.ReadAllText(@\"doc\\template.html\")",
          "                    .Replace(\"$-markdown-body-$\", File.ReadAllText(@\"obj\\doc.html\"))",
          "            );",
          "            return 0;",
          "        }",
          "    }",
          "}"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "ActBin",
      "Caption": "Binaries & tools ...",
      "IgnoreIfBuildFailed": true,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[IO copy.file",
          "(",
          "    {",
          "        \"License.txt\",",
          "        \"changelog.txt\",",
          "        \".version\",",
          "        \".gitattributes\",",
          "        \"Readme.md\",",
          "        \"tests.bat\",",
          "        \".tools/GetNuTool.nuspec\",",
          "        \".pkg.install.bat\",",
          "        \"srv.create.bat\"",
          "    },",
          "    \"$(odir)\",",
          "    true",
          ")]",
          "",
          "#[IO copy.file({\".tools/*.nuspec\"}, \"$(odir)/\", true)]",
          "#[IO replace(\"$(odir)/GetNuTool.nuspec\", \"$-version-$\", \"$(pVer)\")]",
          "",
          "#[IO copy.file({ \"tests/*.bat\" }, \"$(odir)/tests/\", true)]",
          "",
          "#[IO copy.file(\"$(dobj)gnt.min.core\", \"$(odir)core/gnt.core\", true)]",
          "#[IO copy.file(\"$(dobj)GetNuTool.cs\", \"$(odir)csharp/\", true)]",
          "#[IO copy.file(\"$(dobj)gnt.bat\", \"$(odir)shell/batch/\", true)]",
          "#[IO copy.file(\"$(dobj)svc.gnt.bat\", \"$(odir)shell/batch/\", true)]",
          "#[IO copy.file(\"validate.gnt.bat\", \"$(odir)shell/batch/\", true)]",
          "#[IO copy.file(\"$(dobj)caller.bat\", \"$(odir)wrappers/batch/gnt.bat\", true)]",
          "",
          "",
          "#[var buildInfo =  $([System.String]::Concat(\"  \"))",
          "        GetNuTool #[$(pVerPrintApp)]  ( #[$(reltype)] )",
          "        :: Generated by vsSolutionBuildEvent #[$(vsSolutionBuildEvent)]",
          "]",
          "#[IO replace(\"$(odir)/GetNuTool.nuspec\", \"{build_info}\", \"$(buildInfo)\")]",
          "",
          "#[( $(isPubRel) )",
          "{",
          "    #[Core events.Post.item(\"Doc\").run()]",
          "    #[IO copy.file(\"$(dobj)doc.html\", \"$(odir)doc/GetNuTool.$(pVer).html\", true)]",
          "}]",
          "",
          "#[IO copy.file",
          "(",
          "    { \"$(dobj)*.map\", \"$(dobj)*.map.targets\" },",
          "    \"$(odir)maps/\",",
          "    true",
          ")]",
          "",
          "~ demo",
          "",
          "#[$(tpackages = '.tools\\packages.config')]",
          "",
          "#[$(vssbePkgV = $([System.Text.RegularExpressions.Regex]::Match('$([System.IO.File]::ReadAllText($(tpackages)))', 'vsSolutionBuildEvent\" version=\"(.+?)\"').Groups[1].Value))]",
          "",
          "#[IO cmd(\"cd $(dobj) & svc.gnt.bat -embed vsSolutionBuildEvent/$(vssbePkgV) -boot packages\\vsSolutionBuildEvent.$(vssbePkgV)\\GUI -name vsSolutionBuildEvent.$(vssbePkgV)\", 300)]",
          "",
          "#[IO copy.file(\"$(dobj)vsSolutionBuildEvent.$(vssbePkgV).bat\", \"$(odir)demo/batch/\", true)]",
          "",
          "~ sha1",
          "",
          "#[$(shaListDir = \"$(odir)shell/batch/gnt.bat\")]",
          "#[$(searchSubDirs = '0')]",
          "#[$(usefile = 'true')]",
          "#[Core events.Post.item(\"ShaList\").run()]",
          "",
          "#[var _LF= $([System.String]::Concat(\"\\n\"))]",
          "#[var _CRLF= $([System.String]::Concat(\"\\r\\n\"))]",
          "",
          "#[IO copy.file(\"$(odir)shell/batch/gnt.bat\", \"$(odir)shell/batch/gnt.bat.crlf\", true)]",
          "#[File replace(\"$(odir)shell/batch/gnt.bat.crlf\", \"$(_LF)\", \"$(_CRLF)\")]",
          "    #[$(shaListDir = \"$(odir)shell/batch/gnt.bat.crlf\")]",
          "    #[$(searchSubDirs = '0')]",
          "    #[$(usefile = 'true')]",
          "    #[Core events.Post.item(\"ShaList\").run()]",
          "    #[IO delete.files({ \"$(odir)shell/batch/gnt.bat.crlf\" })]",
          "",
          "#[$(shaListDir = $(odir))]",
          "#[$(searchSubDirs = '1')]",
          "#[$(usefile = 'false')]",
          "#[Core events.Post.item(\"ShaList\").run()]"
        ]
      }
    },
    {
      "Enabled": false,
      "Name": "ShaList",
      "SupportSBEScripts": false,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeCSharp, vsSolutionBuildEvent",
        "Type": "CSharp",
        "References": [
          "System.dll"
        ],
        "SmartReferences": true,
        "GenerateInMemory": true,
        "TreatWarningsAsErrors": false,
        "WarningLevel": 4,
        "FilesMode": false,
        "CachingBytecode": false,
        "Command__": [
          "using System;",
          "using System.IO;",
          "using System.Text;",
          "using System.Security.Cryptography;",
          "using ICommand = net.r_eg.vsSBE.Actions.ICommand;",
          "using ISolutionEvent = net.r_eg.vsSBE.Events.ISolutionEvent;",
          "",
          "namespace vsSolutionBuildEvent",
          "{",
          "    public class CSharpMode",
          "    {",
          "        public static int Init(ICommand cmd, ISolutionEvent evt)",
          "        {",
          "            bool usefile = $(usefile);",
          "            ",
          "            string dir = @\"$(shaListDir)\".Replace('/', '\\\\');",
          "",
          "            Func<byte[], string> _BytesToHexView = (data) =>",
          "            {",
          "                var ret = new StringBuilder();",
          "                foreach(byte b in data) ret.Append(b.ToString(\"x2\"));",
          "                return ret.ToString();",
          "            };",
          "",
          "            var values = new StringBuilder();",
          "",
          "            using(SHA1 sha1 = SHA1.Create())",
          "            {",
          "                if(usefile)",
          "                {",
          "                    using(var stream = new FileStream(dir, FileMode.Open, FileAccess.Read))",
          "                    values.Append(_BytesToHexView(sha1.ComputeHash(stream)));",
          "                }",
          "                else",
          "                {",
          "                    foreach(var input in Directory.GetFiles(dir, \"*\", (SearchOption)$(searchSubDirs)))",
          "                    using(var stream = new FileStream(input, FileMode.Open, FileAccess.Read))",
          "                    values.AppendLine(string.Format",
          "                    (",
          "                        \"{0} {1}\",",
          "                        _BytesToHexView(sha1.ComputeHash(stream)),",
          "                        input.Replace(dir, \"\")",
          "                    ));",
          "                }",
          "            }",
          "",
          "            using(var w = new StreamWriter(usefile ? (dir + \".sha1\") : Path.Combine(dir, \".sha1\"), false, new UTF8Encoding(false)))",
          "            w.Write(values.ToString());",
          "",
          "            return 0;",
          "        }",
          "    }",
          "}"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "ActZip",
      "Caption": "Create Zip archive",
      "IgnoreIfBuildFailed": true,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[7z pack.directory(\"$(dbin)raw\", \"$(dbin)GetNuTool.$(pVerPrintFile).zip\")]",
          "",
          "#[IO copy.file(\"$(odir)shell/batch/gnt.bat\", \"$(dbin)\", true)]",
          "",
          "",
          "#[$(shaListDir = $(dbin))]",
          "#[$(searchSubDirs = '0')]",
          "#[$(usefile = 'false')]",
          "#[Core events.Post.item(\"ShaList\").run()]",
          "",
          "",
          "",
          "#[\" https://github.com/3F/DllExport/issues/36 \"]",
          "#[IO copy.directory(\"\", \"$(odir)/lib/net/\", true)]",
          "#[IO write(\"$(odir)/lib/net/_._\"):]",
          "",
          "#[IO copy.directory(\"\", \"$(odir)/lib/netcoreapp/\", true)]",
          "#[IO write(\"$(odir)/lib/netcoreapp/_._\"):]",
          "",
          "#[IO copy.directory(\"\", \"$(odir)/lib/netstandard/\", true)]",
          "#[IO write(\"$(odir)/lib/netstandard/_._\"):]",
          "",
          "~ ~ ~",
          "",
          "#[IO copy.directory(\"\", \"$(odir)build\\native\", true)]",
          "#[IO copy.file(\".tools/GetNuTool.native.targets\", \"$(odir)build\\native/GetNuTool.targets\", true)]",
          "",
          "#[IO copy.directory(\"\", \"$(odir)build\\net\", true)]",
          "#[IO copy.file(\".tools/GetNuTool.dotnet.targets\", \"$(odir)build\\net/GetNuTool.targets\", true)]",
          "",
          "#[IO copy.directory(\"\", \"$(odir)build\\netcoreapp\", true)]",
          "#[IO copy.file(\".tools/GetNuTool.dotnet.targets\", \"$(odir)build\\netcoreapp/GetNuTool.targets\", true)]",
          "",
          "#[IO copy.directory(\"\", \"$(odir)build\\netstandard\", true)]",
          "#[IO copy.file(\".tools/GetNuTool.dotnet.targets\", \"$(odir)build\\netstandard/GetNuTool.targets\", true)]",
          "",
          "",
          "#[IO cmd(\"cd $(dbin) & gnt /t:pack /p:ngin=raw\", 0)]",
          "",
          "~ local server alias to use as `gnt ~/p:ngserver=.\\` or `gnt ~/p:ngserver=bin\\Release\\`",
          "",
          "#[$(dbgSrvDir = \"$(dbin.Replace('/', '\\'))GetNuTool\\\\\")]",
          "",
          "#[IO copy.directory(\"\", \"$(dbgSrvDir)\", true)]",
          "#[IO scall(\"cmd\", \"/C mklink /H $(dbgSrvDir)$(pVer) $(dbin.Replace('/', '\\'))GetNuTool.$(pVer).nupkg\", 0)]"
        ]
      }
    }
  ]
}